# 最常见的sql数据集和参数定义

## sql 数据集
在设计报表的数据集时，sql数据集内部使用参数可以先使用，后定义。参数以两个$包起来，插入到sql语句中。
~~~sql
SELECT [订单明细].[订单ID], [订单明细].[产品ID], [产品].[产品名称], [订单明细].[单价], [订单明细].[数量], [订单明细].[折扣], ([订单明细].[单价]*[数量]*(1-[折扣])/100)*100 AS 总价
FROM 产品 INNER JOIN 订单明细 ON [产品].[产品ID]=[订单明细].[产品ID]
where  
 [订单明细].[订单ID]='$dindan$'
~~~
::: tip
使用$$将参数包起来插入sql的方式，实际上是字符串拼接。引擎内部会自动对参数做sql注入的检测，如果检测到有危险，除非是以缺省值或可选列表值的方式提供的危险参数才可以执行，否则将不会执行，报错退出。
:::
如果参数是字符串，要注意外面的引号不要丢失


~~~sql
#如果需要动态构造sql 语句，比如判断用户是否输入了某个参数，输入的话就拼接指定的sql片段
SELECT [订单明细].[订单ID], [订单明细].[产品ID], [产品].[产品名称], [订单明细].[单价], [订单明细].[数量], [订单明细].[折扣], ([订单明细].[单价]*[数量]*(1-[折扣])/100)*100 AS 总价
FROM 产品 INNER JOIN 订单明细 ON [产品].[产品ID]=[订单明细].[产品ID]
where 1=1

$if(false==isEmpty(param.dindan)){$
 and [订单明细].[订单ID]='$dindan$'
$}$

$if(false==isEmpty(param.chanping)){$
and [订单明细].[产品ID]='$chanping$'
$}$

ORDER BY [订单明细].[订单ID]
~~~

- 上面的例子，是将if 语句用$$包起来插入sql语句中，注意 语句块{、 }不要丢失，否则会报错。条件语句块结束用$}$结束
- 内嵌的模板语句中（上例中的if语句）使用参数时，要用param.参数 的方式。注意区别。
- 当if条件满足的时候，会将紧跟其后的语句块中字符串拼接到当前的sql 中

::: tip
因为这种方式是字符串拼接，所以 sql 语句的任意部分都可以插入$参数$
:::
参数绑定到sql 的时候，不管是什么数据类型，都会将参数值转换为字符串类型，然后插入到sql 的对应位置。如果参数是可以下拉选择的多选形式：
+ 参数是数字类型的，如选中的参数是1、2、3，转换为字符串后是 :   1,2,3  
+ 参数是字符串类型的，如选中的参数是a、b、c，转换为字符串后是 :   'a','b','c'

## 参数定义

+ 在参数定义界面，点按钮：载入未定义的参数，将会自动搜索sql语句中用到的参数。参数的数据类型有：数字、字符串、日期等类型。可以选择对最终页面是否隐藏该参数（html网页上form的hide类型），是否是内部（不会提供给最终用户看到和修改的机会，每次取值都是根据公式计算，相当于内部临时变量），多选（如果是可以下拉选择的时候有效）。当参数的数据类型是日期或者是隐藏、内部等方式下，参数自动不允许被多选。
 
+ 如果参数是内部类型（相当于临时变量），那么他一定是在所依赖参数的后面定义，否则报表运行的时候会报引用了没有定义的参数。通过参数列表定义界面可以拖动参数的相对位置。内部参数通常是根据非内部参数计算出来的新值。
~~~js
// 假如我们已经定义了一个参数叫：b_date，我们现在需要根据这个日期参数，计算这个日期所在月的最后一天
// 我们可以新增一个参数，将选项：内部 √ 上，然后设置缺省值为:
=monthEnd(param.b_date)
// 这样我们就可以在sql 中直接使用这个参数了。
// 如果这个参数在sql中仅使用一次，我们也可以直接将这个公式内联到sql中，用以下语法:   
~~~
 
~~~sql
 #注意第一个$ 后面有个+
select * from tbl where m_date>='$b_date$' and m_date<='$+monthEnd(param.b_date)$'
~~~

+ 每个参数都会有缺省参数，当报表运行的时候，如果没有提供参数值，将会以缺省参数运行。
  
